## 前言
笔者最近的算法学习到了动态规划的阶段，刷了不少动态规划的题，对于动态规划中的背包问题，刚开始真的非常头痛，很多题可能只是稍稍更改了一些约束条件，我就答不出来了。这类题虽然解题的方法都是类似，但是存在很多变种，不同的变种，它所需要修改的解题思路都非常需要去仔细琢磨体会，所以我一开始，不但解题成功率不高，解题速度也是非常慢。在这里，我基于自己的实践以及一些前辈大佬的经验，总结归纳了几个比较基础的解题方法，用来提高解答背包问题的成功率和效率。


## 经典0-1背包问题
我先对最基础的0-1背包问题做一个简单的介绍和回顾，其它的背包问题基本都是这个基础问题的变种。
```html
有一个背包，它的容量为C。现在有n种不同的物品，编号为0...n-1，其中每一件物品的重量为w，价值为v。
问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，物品的总价值最大？
```
本题是最基本的背包问题，有过动态规划学习的同学应该都能很轻松解答出来，我就直接出代码了。
```js
// w代表物品重量的数组
// v代表物品价值的数组
// c是背包的容量
// 本例优化了空间复杂度，把二维数组优化成了一个一维数组
const knapsack01 = (w, v, c) => {
	let len = w.length;
	if (len === 0) return 0;
	let memo = new Array(c + 1).fill(0);
	for (let i = 0; i <= c; i ++) {
		if (i >= w[0]) memo[i] = v[0];
	}

	for (let i = 1; i < len; i ++) {
		for (let j = c; j >= w[i]; j --) {
			memo[j] = Math.max(memo[j], v[i] + memo[j - w[i]]);
		}
	}
	return memo[c];
}
```
举个例子来说明一下这段代码的逻辑：

假设现在有个容量为`c = 5`的背包，有三个物品，它们的重量和价值的数组为
`w = [1, 2, 3]`， `v = [6, 10, 12]`。

我们定义一个二维数组dp，物品个数作为x轴，背包容量作为y轴。dp[i][j]代表当放入背包的物品个数为i + 1时，背包容量为j时，背包里的最大物品价值。dp初始值都为-1，如下:

y轴长度为背包容量 + 1，便于后续计算
|  | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| dp[0] | -1 | -1 | -1 | -1 | -1 | -1 |
| dp[1] | -1 | -1 | -1 | -1 | -1 | -1 |
| dp[2] | -1 | -1 | -1 | -1 | -1 | -1 |


我们先给第一排赋值，当容量为1的时候，才能放下第一个元素，在`dp`中存入该元素的价值，即6。

|  | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| dp[0] | 0 | 6 | 6 | 6 | 6 | 6 |
| dp[1] | -1 | -1 | -1 | -1 | -1 | -1 |
| dp[2] | -1 | -1 | -1 | -1 | -1 | -1 |


然后我们给第二排赋值，因为第二个元素的重量为2，所以以2为标准，这里有三种情况。假设当前节点为`dp[i][j]`
- 当容量小于2的时候，放不下，所以按`dp[i-1][j]`的值来。
- 当容量大于等于2的时候，拿`dp[i-1][j]`和`v[i] + dp[i - 1][c - w[i]]`比较，取较大值。即比较`不使用当前元素的最大值`以及`当前元素价值 + (容量-当前元素重量)时的最大价值`。
  
|  | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| dp[0] | 0 | 6 | 6 | 6 | 6 | 6 |
| dp[1] | 0 | 6 | 12 | 16 | 16 | 16 |
| dp[2] | -1 | -1 | -1 | -1 | -1 | -1 |

最后赋值第三排，也是一样的规则，最终得到
|  | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| dp[0] | 0 | 6 | 6 | 6 | 6 | 6 |
| dp[1] | 0 | 6 | 10 | 16 | 16 | 16 |
| dp[2] | 0 | 6 | 10 | 16 | 18 | 22 |

`dp[2][5]`所代表的值即为我们题目中需要求的最大值。不过我们还可以对空间复杂度进行优化，因为二维数组`dp`在赋值的时候，只需要使用上面以及上一行左侧的元素，所以我们可以用一个一维数组进行优化，在初始化`dp[0]`之后，使用从右往左的顺序来对`dp`进行赋值。上面的例子已经对空间复杂度进行了优化。

## 总结的几种背包问题的基本解题方法
我们常见的有几种背包问题，我先列出它们基本的循环逻辑以及核心的状态转移方程。下面几节，关于这几种常见的背包问题，我都会列一个非常经典的例子来实践。

常见背包问题的特征：

一般都会给出一组数组`nums`，再给一个目标值`target`，要求从`nums`中取出多少个元素可以满足`target`?

### 循环逻辑
#### 类0-1背包问题
`nums`中的数据只能使用一次，不需要顺序关系，它的循环逻辑一般为
> `nums`循环（`x`轴）嵌套`target`循环（`y`轴），且`target`循环倒序
#### 可重复背包
`nums`中的数据可以重复使用，不需要顺序关系
> `nums`循环（`x`轴）嵌套`target`循环（`y`轴），且`target`循环正序
#### 排列背包
`nums`中的数据可重复使用，但是需要考虑元素之间的顺序，不同的顺序代表不同的结果。
> `target`循环（`x`轴）嵌套`nums`循环（`y`轴）, 都正序

### 状态转移方程
#### 数量问题
求有多少种组合，有多少满足条件的项
> dp[i] += dp[i-num];

#### true,false问题
验证是否存在满足条件的项
> dp[i] = dp[i] || dp[i-num];


#### 最大最小问题
求满足条件的最大/小值
> dp[i] = Math.max / min(dp[i], dp[i-num]+1);

## 几道经典例题