/**
 * leetcode 221 
 *
 * 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
 * 
 * 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
 * 输出：4
 */
// 动态规划的思路，dp[i][j]代表以matrix[i][j]作为右下角节点的正方形最大的边长为多少
// 每次获取dp[i][j]只需要取dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]这三种中的最小值再加1即可
var maximalSquare = function(matrix) {
  const xLen = matrix.length;
  const yLen = matrix[0].length;
  const dp = new Array(xLen).fill(0).map(v => new Array(yLen).fill(0));
  let max = 0;
  // 初始化y轴为0的数据，只要为'1'就赋值为1
  for (let i = 0; i < xLen; i ++) {
    if (matrix[i][0] === '1') {
      dp[i][0] = 1;
      max = 1;
    }
  }
  // 初始化x轴为0的数据，只要为'1'就赋值为1
  for (let i = 0; i < yLen; i ++) {
    if (matrix[0][i] === '1') {
      dp[0][i] = 1;
      max = 1;
    }
  }
  // 遍历二维数组
  for (let i = 1; i < xLen; i ++) {
    for (let j = 1; j < yLen; j ++) {
      if (matrix[i][j] === '1') {
        // 如果节点为'1'
        // 取dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]这三种中的最小值再加1
        dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;
        // 保持最大值
        max = Math.max(max, dp[i][j]);
      }
    }
  }
  // 需要的结果是面试，所以边长 * 边长
  return max * max;
};
console.log([["1","0","1","0","0","1","1","1","0"],["1","1","1","0","0","0","0","0","1"],["0","0","1","1","0","0","0","1","1"],["0","1","1","0","0","1","0","0","1"],["1","1","0","1","1","0","0","1","0"],["0","1","1","1","1","1","1","0","1"],["1","0","1","1","1","0","0","1","0"],["1","1","1","0","1","0","0","0","1"],["0","1","1","1","1","0","0","1","0"],["1","0","0","1","1","1","0","0","0"]]);
console.log(maximalSquare([["1","0","1","0","0","1","1","1","0"],["1","1","1","0","0","0","0","0","1"],["0","0","1","1","0","0","0","1","1"],["0","1","1","0","0","1","0","0","1"],["1","1","0","1","1","0","0","1","0"],["0","1","1","1","1","1","1","0","1"],["1","0","1","1","1","0","0","1","0"],["1","1","1","0","1","0","0","0","1"],["0","1","1","1","1","0","0","1","0"],["1","0","0","1","1","1","0","0","0"]]));