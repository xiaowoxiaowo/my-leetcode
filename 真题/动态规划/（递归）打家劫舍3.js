/***
 * leetcode 337
 * 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。
 * 这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。
 * 一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 
 * 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
 * 
 * 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
 * 
 * 
 * 例1：
 * 输入：[3,2,3,null,3,null,1]
 *       3
 *      / \
 *     2   3
 *      \   \
 *       3   1
 * 输出：7
 * 解释：小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
 * 
 * 输入：[3,4,5,1,3,null,1]
 *        3
 *       / \
 *      4   5
 *     / \   \
 *    1   3   1
 * 输出：9
 * 解释：小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
 * 
 * 
 * 解题思路：
 * 在二叉树的递归中使用动态规划，每一个节点都会对应一个有两个值的数组
 * 第一个值代表，当前节点左右两个子节点所能盗取的最高金额之和
 * 第二个值代表，包含当前节点之后，所能盗取的最高金额之和
 */
const rob = (root) => {
  // 本题因为本来就是一个递归算法，不需要声明一个dp数组来记录，直接通过递归的方式，返回顶层即可
  const dfs = (node) => {
    // 到达尾节点，返回[0, 0]
    if (node == null) return [0, 0];
    // 递归左右两个子节点
    const left = dfs(node.left);
    const right = dfs(node.right);
    // 数组的第一个值，左节点以及右节点，所能盗取的最高金额之和（不盗取当前节点）
    const resLeft = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    // 数组的第二个值，盗取当前节点之后，所能盗取的最高金额之和
    const resRight = node.val + left[0] + right[0];
    return [resLeft, resRight];
  };
  const res = dfs(root);
  return Math.max(res[0], res[1]);
};







