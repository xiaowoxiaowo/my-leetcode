/***
 * leetcode 309
 * 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​
 * 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
 * - 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 * - 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
 * 
 * 
 * 例1：
 * 输入：[1,2,3,0,2]
 * 输出：3
 * 解释：对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
 * 
 * 输入：[1,2,3,15,70]
 * 输出：69
 * 
 * 输入：[1,2,5,3,2,30]
 * 输出：32
 * 
 * 
 * 解题思路：
 * 动态规划的思路，因为交易状态有三种，买入，卖出，冷冻期（也可以用来表示啥都不干的状态），
 * 所以我们需要建立一个二维数组，用0，1，2的位置代表这三个状态（靠自己感觉有点难想出来）
 * 每个位置都代表，当前位置相应状态的最大值（每次比较前一位相应操作的值，以及自身操作的值）
 */
var maxProfit = function(prices) {
  let len = prices.length;
  // 创建一个二维数组
  let dp = new Array(len).fill(0).map(v => new Array(3).fill(0))
  // 初始化的买入状态设置初始值
  dp[0][0] = -prices[0];
  for (let i = 1; i < len; i ++) {
    // 买入状态，上一个节点的买入操作后的值， 上一个节点的冻结操作的值-当前值。取这两个值的最大值
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2] - prices[i]);
    // 卖出状态，上一个节点的卖出操作后的值， 上一个节点的买入操作的值（有卖必有买）+当前值。取这两个值的最大值
    dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i]);
    // 冻结状态，没有任何值变化，直接取上一个节点的卖出（三种状态的最大值）
    dp[i][2] = dp[i-1][1];
  }
  return dp[len-1][1];
};

console.log(maxProfit([1,2,3,0,2]));
console.log(maxProfit([1,2,3,15,70]));
console.log(maxProfit([1,2,5,3,2,30]));
console.log(maxProfit([6,1,6,4,3,0,2]));