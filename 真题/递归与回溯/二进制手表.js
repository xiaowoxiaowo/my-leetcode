/***
 * leetcode 401
 * 二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。
 * 每个 LED 代表一个 0 或 1，最低位在右侧。
 * 给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。
 * 
 * 例1：
 * 输入: n = 1
 * 输出：["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]
 * 
 * 说明：
 * 输出的顺序没有要求。
 * 小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。
 * 分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。
 * 超过表示范围（小时 0-11，分钟 0-59）的数据将会被舍弃，也就是说不会出现 "13:00", "0:61" 等时间。
 * 
 * 解题思路：
 * 本题的难点在于，需要把实际的例子，转化为组合排列问题。手表有小时以及分钟两个时间，每个亮着的灯其实可以等效于一个固定的值。
 * 小时灯的数值为[1,2,4,8],分钟灯的数值为[1,2,4,8,16,32]。
 * 可以把这两个数组和为一个数组[1, 2, 4, 8, 1, 2, 4, 8, 16, 32]。
 * 本题就可以抽象为在当前的数组中，存在n（LED亮着的数量）个值，返回所有的可能性。
 */
var readBinaryWatch = function(num) {
  // 抽象出来的数组
  const arr = [1, 2, 4, 8, 1, 2, 4, 8, 16, 32];
  const result = [];
  // 递归方法，传入四个参数，arr数组，num（LED亮着的数量）,start（每次递归循环的起始位置），temp(一个有两个值的数组，代表小时以及分钟值)
  const loop = (arr, num, start, temp) => {
    // 边界情况，小时范围 0-11，分钟范围 0-59
    if (temp[0] >= 12 || temp[1] >= 60) return;
    // 当递归到底的时候，把结果推入result数组中
    if (num === 0) return result.push(`${temp[0]}:${padding(temp[1])}`);
    // 按照传入的start值，从小到大循环
    for (let i = start; i < arr.length; i++) {
      const tmp = [...temp];
      if (i <= 3) {
        // 如果处理的是数组的前4位，把值加到小时位上
        tmp[0] = tmp[0] + arr[i];
      } else {
        // 如果处理的是数组的后面的值，把值加到分钟位上
        tmp[1] = tmp[1] + arr[i];
      }
      // 继续递归
      loop(arr, num - 1, i + 1, tmp)
    }
  }
  loop(arr, num, 0, [0, 0]);
  return result;
};

var padding = function(num) {
  return num < 10 ? `0${num}` : num;
}
