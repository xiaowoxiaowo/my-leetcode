/***
 * leetcode 129
 * 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。每条从根节点到叶节点的路径都代表一个数字：
 * 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
 * 计算从根节点到叶节点生成的 所有数字之和 。
 * 
 * 
 * 例1：
 * 输入: root = [1,2,3]
 * 输出: 25
 * 从根到叶子节点路径 1->2 代表数字 12
 * 从根到叶子节点路径 1->3 代表数字 13
 * 因此，数字总和 = 12 + 13 = 25
 * 
 * 输入: root = [4,9,0,5,1]
 * 输出: 1026
 * 从根到叶子节点路径 4->9->5 代表数字 495
 * 从根到叶子节点路径 4->9->1 代表数字 491
 * 从根到叶子节点路径 4->0 代表数字 40
 * 因此，数字总和 = 495 + 491 + 40 = 1026
 * 
 * 
 * 提示：
 * 树中节点的数目在范围 [1, 1000] 内
 * 0 <= Node.val <= 9
 * 树的深度不超过 10
 * 
 * 解题思路：
 * 递归思路，可以按 二叉树的所有路径 的思路来，将内容加到一个数组中，向上返回的时候，每一层都给数组里unshift一个值。
 * 然后最终得到一个所有路径的数组，最后将这些路径转为数字。
 * 
 * 下面的解答是在遍历的过程中直接计算出结果，计算的关键是将一个总和值遍历下去，每层都把这个值*10,然后加上当前节点值，直到叶子节点。
 */

var sumNumbers = function(root) {
  if (!root) return 0;
  // 遍历
  const loop = (node, sum) => {
    // 如果节点不存在，返回0
    if (!node) return 0;
    // 向下遍历每一层，都将这个值*10，并加上当前节点值
    let res = sum * 10 + node.val;
    // 如果是叶子节点，返回当前值
    if (!node.left && !node.right) return res;
    // 如果不是叶子节点，继续遍历左右子节点树
    return loop(node.left, res) + loop(node.right, res)
  };
  return loop(root, 0);
};
