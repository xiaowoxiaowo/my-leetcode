/***
 * leetcode 96
 * 
 * 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
 * 
 * 
 * 输入：n = 3
 * 输出：5
 *   1       1        2        3    3                  
 *    \       \      / \      /    /                  
 *     3       2    1   3    2    1                    
 *    /         \           /      \
 *   2           3         1        2
 *  
 * 
 * 
 * 
 * 输入：n = 1
 * 输出：1
 * 
 */
// 动态规划的思路，n个节点，其实每次就是求把1...n这几个节点作为根节点时候的种数
// 因为需要组成二叉搜索树，二叉搜索树的根节点左侧的值都比根节点小，右侧的值都比根节点大。
// 所以其实就是求当i作为节点时，（左侧有 i - 1 个节点的组成种数）* （右侧有 n - i 个节点的组成种数）
var numTrees = function(n) {
  if (n <= 1) return n;
  const dp = new Array(n + 1).fill(0);
  // 初始化dp，0个节点只有0种，1个节点只有一种
  dp[0] = 1;
  dp[1] = 1;
  // 遍历[2...n]的节点
  for (let i = 2; i <= n; i ++) {
    // 遍历[1...i]的情况，求这些节点作为根节点时候的种数之和
    for (let j = 1; j <= i; j ++) {
      // 核心转移方程
      dp[i] = dp[i] + dp[j - 1] * dp[i - j];
    }
  }
  return dp[n];
};

console.log(numTrees(3));
console.log(numTrees(4));